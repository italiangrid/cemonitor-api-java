/*
 * Copyright (c) Members of the EGEE Collaboration. 2004. 
 * See http://www.eu-egee.org/partners/ for details on the copyright
 * holders.  
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at 
 *
 *     http://www.apache.org/licenses/LICENSE-2.0 
 *
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an "AS IS" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and 
 * limitations under the License.
 */
 
/*
 *
 * Author Luigi Zangrando <zangrando@pd.infn.it>
 *
 */

package org.glite.ce.monitorapij.sensor;

import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectOutput;
import java.io.ObjectInput;

import org.apache.log4j.Logger;
import org.glite.ce.monitorapij.types.CEResource;
import org.glite.ce.monitorapij.types.TopicEvent;

import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;

/**
 * This class represents an event generated by a <code>Sensor</code>. It is
 * characterized by the Sensor source of this event, the referring time, an
 * identifying String, a Hashtable of parameters and the
 * <code>SensorOutputDataFormat</code> which is applied.
 */
public class SensorEvent implements TopicEvent, Externalizable, CEResource {
    private static final long serialVersionUID = 1L;
    
    private final static Logger logger = Logger.getLogger(SensorEvent.class.getName());

    private int ID;
    private java.util.Calendar timestamp;
    private java.lang.String[] message;
    private java.lang.String producer;
    private Sensor source;
    private String name;
    private Hashtable<String, Object> parameters;
    private String outputDataFormatApplied;
    private Calendar expirationTime;
    private String receiverId;
    private String receiverGroup;
    

    public SensorEvent() {
        this(null, -1, Calendar.getInstance(), null);
    }

    /**
     * Creates a new SensorEvent object specifying the source Sensor and an
     * identifying id. The referring time of the event is set to the current
     * time.
     * 
     * @param source
     *            The source <code>Sensor</code>.
     * @param eventID
     *            An integer identifying this event.
     */
    public SensorEvent(Sensor source, int eventID) {
        this(source, eventID, Calendar.getInstance(), null);
    }

    /**
     * Creates a new SensorEvent object specifying the source Sensor, an
     * identifying id and the referring time of the event.
     * 
     * @param source
     *            The source <code>Sensor</code>.
     * @param eventID
     *            An int identifying this event.
     * @param when
     *            The referring time of this event.
     */
    public SensorEvent(Sensor source, int eventID, Calendar when) {
        this(source, eventID, when, null);
    }

    public SensorEvent(Sensor source, int eventID, Calendar when, Calendar expirationTime) {

        if (source != null) {
            this.source = source;
            this.producer = source.getName();
        }

        setID(eventID);
        setTimestamp(when);
        setExpirationTime(expirationTime);
        parameters = new Hashtable<String, Object>(0);
    }


    /**
     * Gets the ID value for this EventBase.
     * 
     * @return ID
     */
    public int getID() {
        return ID;
    }


    /**
     * Sets the ID value for this EventBase.
     * 
     * @param ID
     */
    public void setID(int ID) {
        this.ID = ID;
    }


    /**
     * Gets the timestamp value for this EventBase.
     * 
     * @return timestamp
     */
    public java.util.Calendar getTimestamp() {
        return timestamp;
    }


    /**
     * Sets the timestamp value for this EventBase.
     * 
     * @param timestamp
     */
    public void setTimestamp(java.util.Calendar timestamp) {
        this.timestamp = timestamp;
    }


    /**
     * Gets the message value for this EventBase.
     * 
     * @return message
     */
    public java.lang.String[] getMessage() {
        return message;
    }


    /**
     * Sets the message value for this EventBase.
     * 
     * @param message
     */
    public void setMessage(java.lang.String[] message) {
        this.message = message;
    }

    public java.lang.String getMessage(int i) {
        return message[i];
    }

    public void setMessage(int i, java.lang.String _value) {
        message[i] = _value;
    }

    protected String getOutputDataFormatApplied() {
        return outputDataFormatApplied;
    }

    protected void setOutputDataFormatApplied(String outputDataFormatApplied) {
        this.outputDataFormatApplied = outputDataFormatApplied;
    }
    
    /**
     * Gets the producer value for this EventBase.
     * 
     * @return producer
     */
    public java.lang.String getProducer() {
        return producer;
    }


    /**
     * Sets the producer value for this EventBase.
     * 
     * @param producer
     */
    public void setProducer(java.lang.String producer) {
        this.producer = producer;
    }

    
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    /**
     * Gets the expirationTime value for this SensorEvent.
     * 
     * @return expirationTime
     */
    public java.util.Calendar getExpirationTime() {
        return expirationTime;
    }

    /**
     * Sets the expirationTime value for this SensorEvent.
     * 
     * @param expirationTime
     */
    public void setExpirationTime(java.util.Calendar expirationTime) {
        this.expirationTime = expirationTime;
    }

    public boolean isExpired() {
        return Calendar.getInstance().after(expirationTime);
    }    
        
    public String getReceiverId() {
        return receiverId;
    }

    public void setReceiverId(String receiverId) {
        this.receiverId = receiverId;
    }

    public String getReceiverGroup() {
        return receiverGroup;
    }

    public void setReceiverGroup(String group) {
        this.receiverGroup = group;
    }

    /**
     * Get the <code>SensorOutputDataFormat</code> applied to this event.
     * 
     * @return The <code>SensorOutputDataFormat</code> applied to this event.
     */
    public SensorOutputDataFormat getSensorOutputDataFormatApplied() {
        if(source == null) {
            return null;            
        }
        return getSource().getFormat(outputDataFormatApplied);
    }

    /**
     * Get the parameter named as specified.
     * 
     * @param name
     *            The name of the searched parameter.
     * 
     * @return The searched parameter or null if this does not exist.
     */
    public Object getParameter(String name) {
        return parameters.get(name);
    }

    /**
     * Add a parameter specifying name and value.
     * 
     * @param name
     *            The name of the parameter.
     * @param value
     *            The value of the parameter.
     */
    public void addParameter(String name, Object value) {
        parameters.put(name, value);
    }

    /**
     * Set the all parameters of this event.
     * 
     * @param parameters
     *            A Hashtable containing the pairs name-value of all the
     *            parameters.
     */
    public void setParameters(Hashtable<String, Object> parameters) {
        this.parameters = parameters;
    }

    /**
     * Get the all parameters of this event.
     * 
     * @return The Hashtable containing the pairs name-value of all the
     *         parameters.
     */
    public Hashtable<String, Object> getParameters() {
        return parameters;
    }

    /**
     * Apply a format to this event. This format is a
     * <code>SensorOutputDataFormat</code> specified by its name and must be
     * supported by the <code>Sensor</code>. If specified format name is null
     * or "default", the default format of the Sensor will be applied.
     * 
     * @param format
     *            The format name.
     * 
     * @throws SensorException
     */
    public void applyFormat(String format) throws SensorException {
        Sensor sensor = getSource();
        
        if(sensor == null) {
            throw new SensorException("sensor not found!");
        }
        
        SensorOutputDataFormat dataformat = null;
        logger.debug("ApplyFormat name = " + getName() + "  format = " + format + " getSource() != null? " + (getSource()!=null));
        if ((format == null) || format.equalsIgnoreCase("default")) {
            dataformat = sensor.getDefaultFormat();
        } else {
            dataformat = sensor.getFormat(format);
        }

        applyFormat(dataformat);
    }

    /**
     * Apply a format to this event specifying the
     * <code>SensorOutputDataFormat</code>. The must be supported by the
     * <code>Sensor</code>.
     * 
     * @param dataformat
     *            The <code>SensorOutputDataFormat</code> to apply.
     * 
     * @throws SensorException
     *             An exception is thrown if the specified
     *             <code>SensorOutputDataFormat</code> is null or is not
     *             supported by the source <code>Sensor</code>.
     */
    public void applyFormat(SensorOutputDataFormat dataformat) throws SensorException {
        if (dataformat == null) {
            throw (new SensorException(
                    "SensorEvent applyFormat: the sensor output dataformat is null!"));
        }

        if (!getSource().isFormatSupported(dataformat)) {
            throw (new SensorException("SensorEvent applyFormat: \"" + dataformat.getName()
                    + "\" format not supported!"));
        }

        try {
            String[] msg = dataformat.apply(parameters);
            setMessage((String[]) msg.clone());
            outputDataFormatApplied = dataformat.getName();
        } catch (Exception ex) {
            logger.error(ex.getMessage(), ex);
            throw (new SensorException(ex.getMessage()));
        }
    }

    /**
     * Get the source <code>Sensor</code>, i.e. the sensor which generated
     * this event.
     * 
     * @return The source <code>Sensor</code>.
     */
    public Sensor getSource() {
        return source;
    }

    public void setSource(Sensor source) {
        this.source = source;
        if(source != null) {
            producer = source.getName();
        } else {
            producer = "N/A";
        }
    }
    
    
    
    /**
     * Get an event identical to this one.
     * 
     * @return The cloned event.
     */
    public Object clone() {
        logger.debug("Clone name = " + getName()  + "  producer = " + producer + "    getSource() != null? " + (getSource()!=null));
        SensorEvent event = new SensorEvent(getSource(), getID(), getTimestamp());
        event.setName(getName());                
        event.setReceiverId(getReceiverId());
        event.setReceiverGroup(getReceiverGroup());
        event.setProducer(getProducer());

        if (getMessage() != null) {
            event.setMessage((String[]) getMessage().clone());
        }
        if (parameters != null) {
            event.setParameters((Hashtable<String, Object>) parameters.clone());
        }
        if (expirationTime != null)
            event.setExpirationTime((Calendar) expirationTime.clone());

        return event;
    }

    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeInt(getID());
        writeString(out, name);
        writeString(out, producer);
        writeString(out, receiverId);
        writeString(out, receiverGroup);
        writeString(out, outputDataFormatApplied);
        writeCalendar(out, expirationTime);
        writeCalendar(out, getTimestamp());
        writeStringArray(out, getMessage());
        
        if (parameters != null) {
            out.writeInt(parameters.size());
            Enumeration<String> allKeys = parameters.keys();
            while (allKeys.hasMoreElements()) {
                String key = (String) allKeys.nextElement();
                writeString(out, key);
                out.writeObject(parameters.get(key));
            }
        } else {
            out.writeInt(-1);
        }

    }
    

    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
        setID(in.readInt());
        setName(readString(in));
        setProducer(readString(in));
        setReceiverId(readString(in));
        setReceiverGroup(readString(in));
        outputDataFormatApplied = readString(in);
        setExpirationTime(readCalendar(in));
        setTimestamp(readCalendar(in));
        setMessage(readStringArray(in));
        
        int htSize = in.readInt();
        if (htSize >= 0) {
            Hashtable<String, Object> parameters = new Hashtable<String, Object>(htSize);
            for (int k = 0; k < htSize; k++) {
                parameters.put(in.readUTF(), in.readObject());
            }
            setParameters(parameters);
        } else {
            setParameters(null);
        }        

    }

    private void writeStringArray(ObjectOutput out, String[] array) throws IOException {
        if (array != null) {
            out.writeInt(array.length);
            
            for (int k = 0; k < array.length; k++) {
                if (array[k] != null)
                    out.writeUTF(array[k]);
                else
                    out.writeUTF("_NULL_");
            }
        } else {
            out.writeInt(-1);
        }
    }

    private String[] readStringArray(ObjectInput in) throws IOException {
        int size = in.readInt();
        if (size >= 0) {
            String[] result = new String[size];
            for (int k = 0; k < size; k++) {
                String s = in.readUTF();
                if(s != null) {
                    result[k] = s;
                }
                
            }
            return result;
        }

        return null;
    }

    private String readString(ObjectInput in) throws IOException {
        String s = in.readUTF();
        
        if(s != null && !s.endsWith("_NULL_")) {
            return s;
        }
        return null;
    }
    
    private void writeString(ObjectOutput out, String s) throws IOException {
        if (s != null)
            out.writeUTF(s);
        else
            out.writeUTF("_NULL_");
    }

    private void writeCalendar(ObjectOutput out, Calendar cal) throws IOException {
        if (cal != null)
            out.writeLong(cal.getTimeInMillis());
        else
            out.writeLong(0);
    }

    private Calendar readCalendar(ObjectInput in) throws IOException {
        long ts = in.readLong();
        if (ts == 0)
            return null;
        Calendar result = Calendar.getInstance();
        result.setTimeInMillis(ts);
        return result;
    }
}
